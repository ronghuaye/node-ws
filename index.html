<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>五子棋（人机 / 双人 对弈）</title>
<style>
  :root{--board-size:640px}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:16px;display:flex;flex-direction:column;align-items:center;gap:12px;color:#111}
  header{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  canvas{background:#f5deb3;border:1px solid #666;touch-action:none}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .controls > *{padding:6px 8px;border-radius:6px;border:1px solid #ccc;background:#fff}
  label.select{display:flex;gap:6px;align-items:center}
  button{cursor:pointer}
  #status{min-width:220px}
  footer{font-size:12px;color:#666}
  @media (max-width:600px){:root{--board-size:320px}}
</style>
</head>
<body>
  <h2>五子棋 — 人机 / 双人 对弈</h2>

  <header class="controls">
    <div>
      <label class="select">模式：
        <select id="modeSelect">
          <option value="pvc" selected>人机对战</option>
          <option value="pvp">双人对战</option>
        </select>
      </label>
    </div>

    <div>
      <label class="select">先手：
        <select id="firstSelect">
          <option value="human">玩家先（黑）</option>
          <option value="ai">电脑先（黑）</option>
        </select>
      </label>
    </div>

    <div>
      <label class="select">AI 难度（搜索深度）：
        <select id="depthSelect">
          <option value="1">1（弱）</option>
          <option value="2">2（入门）</option>
          <option value="3" selected>3（推荐）</option>
          <option value="4">4（较强，慢）</option>
          <option value="5">5（很慢，仅高配）</option>
        </select>
      </label>
    </div>

    <button id="newBtn">重开</button>
    <button id="undoBtn">悔棋</button>
    <div id="status">状态：准备就绪</div>
  </header>

  <canvas id="boardCanvas" width="640" height="640" style="width:var(--board-size);height:var(--board-size)"></canvas>

  <footer>说明：点击棋盘落子。模式选择为“人机”或“双人”。悔棋会撤销最后双方各一步（人机）或最后一步（双人）。</footer>

<script>
/* TL;DR: 单文件五子棋，支持 PvC 与 PvP 模式，AI 使用启发式 minimax + alpha-beta，提供悔棋/重开/难度切换。 */

// --- 配置 ---
const N = 15;           // 棋盘大小
const CELL = 40;        // 每格像素（canvas 尺寸 = N*CELL）
const canvas = document.getElementById('boardCanvas');
canvas.width = N * CELL; canvas.height = N * CELL;
const ctx = canvas.getContext('2d');

// --- 状态 ---
let board = [];         // 0 empty, 1 black, 2 white
let currentPlayer = 1;  // 1 black, 2 white
let humanPlayer = 1;    // 在 PvC 模式中玩家是哪一方
let aiPlayer = 2;
let moveStack = [];
let gameOver = false;
let mode = 'pvc';       // 'pvc' or 'pvp'
let depthLimit = 3;

// --- UI refs ---
const statusEl = document.getElementById('status');
const firstSelect = document.getElementById('firstSelect');
const depthSelect = document.getElementById('depthSelect');
const newBtn = document.getElementById('newBtn');
const undoBtn = document.getElementById('undoBtn');
const modeSelect = document.getElementById('modeSelect');

// --- 初始化 ---
function initBoard(){
  board = Array.from({length:N}, ()=>Array(N).fill(0));
  moveStack = [];
  gameOver = false;
  depthLimit = parseInt(depthSelect.value,10);
  mode = modeSelect.value;

  if (mode === 'pvp'){
    humanPlayer = null; aiPlayer = null; // 非 AI 模式
    currentPlayer = 1; // 黑先
    status('双人对战：黑方先手');
    draw();
    return;
  }

  // PvC 模式
  const first = firstSelect.value;
  if (first === 'human'){
    humanPlayer = 1; aiPlayer = 2; currentPlayer = 1;
    status('人机对战：玩家（黑）先手');
  } else {
    // 电脑黑先
    humanPlayer = 2; aiPlayer = 1; currentPlayer = 1;
    status('人机对战：电脑（黑）先手，正在落子...');
    // 延迟一帧以便 UI 更新
    setTimeout(()=> aiMove(), 80);
  }
  draw();
}

function status(text){ statusEl.textContent = '状态：' + text; }

// --- 绘制 ---
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid(); drawCoords(); drawPieces();
}
function drawGrid(){
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  // 国际标准棋盘：线条从边界到边界
  for (let i = 0; i < N; i++){
    const pos = i * CELL + CELL/2;
    // 横线
    ctx.beginPath();
    ctx.moveTo(CELL/2, pos);
    ctx.lineTo(canvas.width - CELL/2, pos);
    ctx.stroke();
    // 竖线
    ctx.beginPath();
    ctx.moveTo(pos, CELL/2);
    ctx.lineTo(pos, canvas.height - CELL/2);
    ctx.stroke();
  }
  // 星位（3,3）、（7,7）、（11,11）
  const stars = [3,7,11];
  for (const r of stars) for (const c of stars){
    ctx.beginPath();
    ctx.fillStyle = '#444';
    ctx.arc((c+0.5)*CELL, (r+0.5)*CELL, 4, 0, Math.PI*2);
    ctx.fill();
  }
}
function drawCoords(){
  ctx.fillStyle = '#333';
  ctx.font = '12px sans-serif';
  // 列坐标：A B C D E F G H J K L M N O P（跳过 I）
  const letters = ['A','B','C','D','E','F','G','H','J','K','L','M','N','O','P'];
  for (let c = 0; c < N; c++){
    ctx.fillText(letters[c], (c + 0.5) * CELL - 4, 12);
    ctx.fillText(letters[c], (c + 0.5) * CELL - 4, canvas.height - 4);
  }
  // 行坐标：1~15
  for (let r = 0; r < N; r++){
    ctx.fillText((r + 1).toString(), 2, (r + 0.5) * CELL + 4);
    ctx.fillText((r + 1).toString(), canvas.width - 18, (r + 0.5) * CELL + 4);
  }
}
function drawPieces(){
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]!==0){ const x=(c+0.5)*CELL,y=(r+0.5)*CELL; const color = board[r][c]===1? '#111':'#eee'; ctx.beginPath(); ctx.fillStyle=color; ctx.arc(x,y,CELL*0.4,0,Math.PI*2); ctx.fill(); ctx.strokeStyle=board[r][c]===1? 'rgba(255,255,255,0.15)':'rgba(0,0,0,0.15)'; ctx.stroke(); }
}

// --- 输入 ---
canvas.addEventListener('pointerdown', (ev)=>{
  if (gameOver) return;
  // account for CSS scaling / HiDPI: map client coords -> canvas pixel coords
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (ev.clientX - rect.left) * scaleX;
  const y = (ev.clientY - rect.top) * scaleY;
  const cellSizeX = canvas.width / N;
  const cellSizeY = canvas.height / N;
  const c = Math.floor(x / cellSizeX);
  const r = Math.floor(y / cellSizeY);

  if (!inBounds(r,c) || board[r][c] !== 0) return;

  if (mode === 'pvp'){
    doMove(r,c,currentPlayer);
    return;
  }

  // PvC 模式: 只允许玩家在其回合落子
  if (currentPlayer !== humanPlayer) return;
  doMove(r,c,humanPlayer);
  if (!gameOver && currentPlayer === aiPlayer) {
    status('电脑思考中...');
    setTimeout(()=> aiMove(), 60);
  }
});

// --- 对弈 / 落子 ---
function doMove(r,c,player){
  board[r][c] = player; moveStack.push({r,c,player}); draw();
  if (isWin(board,r,c,player)){ gameOver = true; status(player === humanPlayer ? '玩家 胜利！' : (mode==='pvp' ? (player===1?'黑棋 胜利！':'白棋 胜利！') : '电脑 胜利！')); return; }
  if (moveStack.length >= N*N){ gameOver=true; status('平局'); return; }
  currentPlayer = 3 - currentPlayer;
  if (mode === 'pvp'){
    status(currentPlayer===1? '黑方回合' : '白方回合');
  } else {
    status(currentPlayer === humanPlayer ? '玩家回合' : '电脑回合');
  }
}

// --- 悔棋 ---
undoBtn.addEventListener('click', ()=>{
  if (moveStack.length === 0 || gameOver) return;
  if (mode === 'pvp'){
    const last = moveStack.pop(); board[last.r][last.c] = 0; currentPlayer = last.player; gameOver = false; draw(); status('已悔棋，轮到 ' + (currentPlayer===1? '黑方':'白方'));
    return;
  }
  // PvC: 撤销人机双方的最后两步（若存在）
  const last = moveStack.pop(); board[last.r][last.c] = 0;
  if (moveStack.length>0){ const last2 = moveStack.pop(); board[last2.r][last2.c] = 0; }
  currentPlayer = humanPlayer; gameOver = false; draw(); status('已悔棋，玩家回合');
});

// --- 新游戏 / 控件绑定 ---
newBtn.addEventListener('click', ()=> initBoard());
depthSelect.addEventListener('change', ()=> depthLimit = parseInt(depthSelect.value,10));
firstSelect.addEventListener('change', ()=> initBoard());
modeSelect.addEventListener('change', ()=> initBoard());

// --- 工具 ---
function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }
function isWin(b,r,c,player){ const dirs = [[0,1],[1,0],[1,1],[1,-1]]; for (const [dr,dc] of dirs){ let cnt=1, i=1; while (inBounds(r+dr*i,c+dc*i) && b[r+dr*i][c+dc*i]===player){cnt++; i++;} i=1; while (inBounds(r-dr*i,c-dc*i) && b[r-dr*i][c-dc*i]===player){cnt++; i++;} if (cnt>=5) return true; } return false; }

// --- AI（PvC 模式） ---
const SCORE = { 'FIVE':1e9, 'OPEN_FOUR':1e6, 'CLOSED_FOUR':1e5, 'OPEN_THREE':1e4, 'CLOSED_THREE':1e3, 'OPEN_TWO':100, 'CLOSED_TWO':10 };

function generateCandidates(b){ const mark = Array.from({length:N}, ()=>Array(N).fill(false)); let hasAny=false; for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (b[r][c]!==0){ hasAny=true; for (let dr=-2;dr<=2;dr++) for (let dc=-2;dc<=2;dc++){ const rr=r+dr, cc=c+dc; if (inBounds(rr,cc) && b[rr][cc]===0) mark[rr][cc]=true; } }
  const res=[]; if (!hasAny){ res.push({r:Math.floor(N/2),c:Math.floor(N/2)}); return res; }
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (mark[r][c]) res.push({r,c});
  // ordering
  res.sort((a,b)=> evaluateMoveScore(b.r,b.c,b) - evaluateMoveScore(a.r,a.c,b));
  return res;
}
function evaluateMoveScore(r,c, boardRef){ let score=0; for (let dr=-2;dr<=2;dr++) for (let dc=-2;dc<=2;dc++){ const rr=r+dr, cc=c+dc; if (inBounds(rr,cc) && boardRef[rr][cc]!==0) score += (boardRef[rr][cc]===aiPlayer?3:1); } return score; }

function evaluateBoard(b, ai){ const human = 3-ai; let aiScore=0, huScore=0; const dirs=[[0,1],[1,0],[1,1],[1,-1]];
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (b[r][c]!==0) for (const [dr,dc] of dirs){ const pr=r-dr, pc=c-dc; if (inBounds(pr,pc) && b[pr][pc]===b[r][c]) continue; let len=0, rr=r, cc=c; while (inBounds(rr,cc) && b[rr][cc]===b[r][c]){ len++; rr+=dr; cc+=dc; } const end1r=r-dr,end1c=c-dc,end2r=rr,end2c=cc; const end1=inBounds(end1r,end1c)? b[end1r][end1c] : -1; const end2=inBounds(end2r,end2c)? b[end2r][end2c] : -1; const openEnds = (end1===0?1:0) + (end2===0?1:0); let val=0; if (len>=5) val=SCORE.FIVE; else if (len===4 && openEnds===2) val=SCORE.OPEN_FOUR; else if (len===4 && openEnds===1) val=SCORE.CLOSED_FOUR; else if (len===3 && openEnds===2) val=SCORE.OPEN_THREE; else if (len===3 && openEnds===1) val=SCORE.CLOSED_THREE; else if (len===2 && openEnds===2) val=SCORE.OPEN_TWO; else if (len===2 && openEnds===1) val=SCORE.CLOSED_TWO; if (b[r][c]===ai) aiScore += val; else huScore += val; }
  return aiScore - huScore; }

function minimax(b, depth, alpha, beta, maximizing, player){ const evalVal = evaluateBoard(b, aiPlayer); if (Math.abs(evalVal) >= SCORE.FIVE || depth===0) return evalVal; const candidates = generateCandidates(b); if (candidates.length===0) return 0; if (maximizing){ let maxEval=-Infinity; for (const mv of candidates){ b[mv.r][mv.c] = player; if (isWin(b,mv.r,mv.c,player)){ b[mv.r][mv.c] = 0; return SCORE.FIVE; } const val = minimax(b, depth-1, alpha, beta, false, 3-player); b[mv.r][mv.c] = 0; if (val > maxEval) maxEval = val; if (val > alpha) alpha = val; if (alpha >= beta) break; } return maxEval; } else { let minEval=Infinity; for (const mv of candidates){ b[mv.r][mv.c] = player; if (isWin(b,mv.r,mv.c,player)){ b[mv.r][mv.c] = 0; return -SCORE.FIVE; } const val = minimax(b, depth-1, alpha, beta, true, 3-player); b[mv.r][mv.c] = 0; if (val < minEval) minEval = val; if (val < beta) beta = val; if (alpha >= beta) break; } return minEval; } }

function aiMove(){ if (gameOver) return; const depth = Math.max(1, Math.min(5, parseInt(depthSelect.value,10)));
  const candidates = generateCandidates(board);
  // immediate win
  for (const mv of candidates){ board[mv.r][mv.c] = aiPlayer; if (isWin(board,mv.r,mv.c,aiPlayer)){ board[mv.r][mv.c] = 0; doMove(mv.r,mv.c,aiPlayer); return; } board[mv.r][mv.c] = 0; }
  // block opponent win
  for (const mv of candidates){ board[mv.r][mv.c] = humanPlayer; if (isWin(board,mv.r,mv.c,humanPlayer)){ board[mv.r][mv.c] = 0; doMove(mv.r,mv.c,aiPlayer); return; } board[mv.r][mv.c] = 0; }
  let best=null, bestVal=-Infinity;
  for (const mv of candidates){ board[mv.r][mv.c] = aiPlayer; const val = minimax(board, depth-1, -Infinity, Infinity, false, humanPlayer); board[mv.r][mv.c] = 0; if (val > bestVal){ bestVal = val; best = mv; } }
  if (best){ doMove(best.r,best.c,aiPlayer); } else { const empties=[]; for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]===0) empties.push({r,c}); if (empties.length>0){ const mv=empties[Math.floor(Math.random()*empties.length)]; doMove(mv.r,mv.c,aiPlayer); } }
}

// --- 启动并暴露调试 ---
initBoard(); window.gomoku = { board, doMove, aiMove, initBoard };
</script>
</body>
</html>
